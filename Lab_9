# k = Integers(10)[x]
# I = k.ideal(x,2)
# S = k.quotient(I)
# S.is_finite()
#
#
# #task_1:
# diln_1 = phi(n)
# diln_0 = n - phi(n) - 1
# nilpot = а среди делителей 0
# a - nilpot <=>  a делится на все простые делители n
#
#
def euclide(a,b):
     r=a%b
     q = a//b
     print (a,'    ',b,'    ',q,'    ',r)
     while r != 0:
         a=b; b=r
         r=a%b
         q = a//b
         print (a,'    ',b,'    ',q,'    ',r)

euclide(f,g)

#----------------------------- 1 -----------------------------
def nil(n):
    res = 1
    for i in range(2,n+1):
        if n%i == 0 and is_prime(i):
            res *= i
    return res

def task_1(n):
    R = Integers(n)
    diln_1 = euler_phi(n)
    print('Divisors of 1: ',diln_1)
    diln_0 = n - diln_1 - 1
    print('Divisors of 0: ',diln_0)
    nilpot = nil(diln_0)

#----------------------------- 2 -----------------------------
def task_2(n):
    R = Integers(n)
    K.<x> = R[]
    a = K.random_element()
    b = K.random_element()
    I = K.ideal(a, b)
    print(a, b, I.is_principal())
    print(I.gen())
    factor = R.quotient(I)
    deg = order(factor)
    diln_0 = n - euler_phi(n) - 1
    print('Divisors of 0: ',diln_0)

#----------------------------- 3 -----------------------------

def count(p, k):
    start = [1] + [0 for i in range(k)]
    iters = p ** k * (p - 1) - 1
    for i in range(iters):
        for i in range(len(start) - 1, -1, -1):
            if start[i] == p - 1:
                start[i] = 0
            else:
                start[i] += 1
                break
        yield start


def poly(p, k):
    for i in range(k + 1):
        for lst in count(p, i):
            yield lst


def _poly(coef):
    sign = list(reversed(coef))
    tmp = list(reversed(['({}*x^{})'.format(coef[i], i) for i in range(len(coef))]))
    return '+'.join(tmp)


def task3(p, k):
    R = Integers(p)
    K.<x> = R[]
    for sign in poly_signatures(p, k):
        sign_str = _poly_sign2str(sign)
        p = K(sign_str)
        print(str(p) + ' --> ' +  str(p.factor()))
