# p = 13
# G = GF(p) -группа % от деления на p
# phi(13) - n способов выбрать производный элемент
#  a = G.primitive_element()
#
#
#  #--------------------------------------------------
#  G = (a) - order n
#  b in G
#  x = order_a(b) - ?
#
#  a**k * b**l = a**K * b**L
#  a**k * a**(x*l) = a**K * a**(x*L)
#  k + xl = K + x*L  mod(n)
#  x(L-l) = k - K mod(n)
#  L - l != 0 mod(n)
#  x = (L-l)**(-1)*(k-K)

#  x_i =
#  from random import sample
#  sample(sequence, num)

import time
def benchmark(f):
    def decor(*args, **kwargs):
        t0 = time.time()
        res = f(*args, **kwargs)
        t1 = time.time()
        print(t1-t0)
        return res
    return decor


#---------------------------------- Task 1 ----------------------------------
import random
from collections import defaultdict

def inp():
    while True:
        p = int(input('Input prime number: '))
        if is_prime(p):
            return p


# def intersection(G):
#     d = defaultdict(str)
#     for i in G:
#         d[i] = random.randrange(0,3)
#     S0 = []
#     S1 = []
#     S2 = []
#     for i in d.keys():
#         if d[i] == 0:
#             S0.append(i)
#         elif d[i] == 1:
#             S1.append(i)
#         else:
#             S2.append(i)
#     return S0, S1, S2


def intersect(G):
    def _clear(s,g):
        for i in s:
            g.remove(i)
        return g
    g = list(G)
    n = order(G)
    s0 = random.sample(g,n//3)
    n0 = n - n//3
    g = _clear(s0,g)
    s1 = random.sample(g,n0//2)
    s2 = _clear(s1,g)
    return s0, s1, s2


def f(x,a,b):
    if x in S0:
        return x * b
    elif x in S1:
        return x**2
    else:
        return x * a

def g(x,k,p):
    if x in S0:
        return k
    elif x in S1:
        return mod(2*k, p-1)
    else:
        return mod(k+1, p-1)


def h(x,k,p):
    if x in S0:
        return mod(k+1, p-1)
    elif x in S1:
        return mod(2*k, p-1)
    else:
        return k


def polard_algorythm(Group,b,a):
    x0 = 1 #identity element
    S0,S1,S2 = intersect(Group)
    global S0,S1,S2
    # a = Group.primitive_element()
    n = order(Group)
    i = 1
    a0 = 0
    b0 = 0
    x0_i = x0
    x0_2i = x0
    a0_i = a0
    a0_2i = a0
    b0_i = b0
    b0_2i = b0
    while i < n:
        xi = mod(f(x0_i,a,b),n)
        ai = g(x0_i, a0, n)
        bi = h(x0_i, b0, n)
        x2i = mod(f(f(x0_2i,a,b),a,b),n)
        a2i = g(f(x0_2i,a,b),g(x0_2i, a0_2i,n),n)
        b2i = h(f(x0_2i,a,b),g(x0_2i, b0_2i,n),n)
        print(i)
        print(xi,x2i)
        print(ai,a2i)
        print(bi,b2i)
        if xi == x2i:
            r = bi - b2i
            print('r',r)
            if r == 0:
                return Exception('Error, try one more time')
            else:
                return mod(float(r)**-1 * float(a2i - ai), n)
        else:
            i += 1
            x0_i = xi
            x0_2i = x2i
            a0_i = ai
            a0_2i = a2i
            b0_i = bi
            b0_2i = b2i



#p = inp()
G = GF(13)
#element = int(input('Input element ord you want to know: '))
base = G.primitive_element()
print(polard_algorythm(G,3,2))
#---------------------------------- Task 2 ----------------------------------
print(polard_algorythm(element,base))

@benchmark
def diskr(element,base):
    return discrete_log(element,base)
print(diskr(element,base))
#---------------------------------- Task 3 ----------------------------------
def task_3(n):
    S = SymmetricGroup(n)
    a = S.random_element()
    A = S.subgroup([a])
    b = A.random_element()
    #print(polard_algorythm(S,b,a))
    print(discrete_log(b,a))

n = int(input('Input n: '))
task_3(n)
